use std::thread::{JoinHandle, Thread};

use channel::Sender;

use crate::Reducer;

pub(crate) mod channel;
mod runtime;

pub(crate) mod testing;

#[doc = include_str!("README.md")]
pub struct Store<State: Reducer> {
    sender: Sender<Result<<State as Reducer>::Action, Thread>>,
    handle: JoinHandle<<State as Reducer>::Output>,
}

impl<State: Reducer> Store<State> {
    /// Creates a new `Store` with `state` as its initial state.
    ///
    /// If `State` is not [`Send`], then [`new`][`Store::new`] or [`default`][`Store::default`]
    /// can be used instead.
    pub fn with_initial(state: State) -> Self
    where
        State: Send + 'static,
        <State as Reducer>::Action: Send,
        <State as Reducer>::Output: Send + From<State>,
    {
        Store::runtime(|| state)
    }

    /// Creates a new `Store` with its initial state generated by a function.
    ///
    /// Useful if `State` is not [`Send`], but the arguments used to construct it are.
    pub fn new<F>(with: F) -> Self
    where
        F: (FnOnce() -> State) + Send + 'static,
        <State as Reducer>::Action: Send + 'static,
        <State as Reducer>::Output: Send + From<State> + 'static,
    {
        Store::runtime(with)
    }

    /// Calls the `Store`’s [`Reducer`][`crate::Reducer`] with `action`.
    ///
    /// Takes an [`Into<Action>`] so that both child and parent `Action`s may be sent easily.
    pub fn send(&self, action: impl Into<<State as Reducer>::Action>) {
        self.sender.send(Ok(action.into()))
    }

    /// Calls the `Store`’s [`Reducer`][`crate::Reducer`] with `action`. and waits until
    /// the `Reducer` has performed the `action`.
    /// ## Note
    /// - This is a blocking call and is usually not what is wanted.
    /// - It does not wait for any `effect`s triggered by the `action`.
    pub fn sync(&self, action: impl Into<<State as Reducer>::Action>) {
        self.sender.sync(Ok(action.into()))
    }

    /// Stops the `Store`’s runtime and returns its current `state` value.  
    ///
    /// # Note
    /// Care should be exercised when using this method in applications that utilize
    /// asynchronous [`Effects`][`crate::effects::Effects`]. `into_inner` makes a “best effort”
    /// to wait until any pending tasks are completed but it is not guaranteed.
    pub fn into_inner(self) -> <State as Reducer>::Output {
        self.sender.send(Err(std::thread::current()));
        std::thread::park(); // waiting for any async tasks to finish up

        drop(self.sender); // ends the runtime’s (outer) while-let
        std::thread::yield_now(); // give it time to shut down
        self.handle.join().unwrap()
    }
}

impl<State: Reducer> Default for Store<State>
where
    State: Default,
    <State as Reducer>::Action: Send + 'static,
    <State as Reducer>::Output: Send + From<State> + 'static,
{
    /// Creates a new `Store` with a default initial state.
    fn default() -> Self {
        Store::new(|| State::default())
    }
}
